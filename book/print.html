<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PRQL Language Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Modern language for transforming data — a simple, powerful, pipelined SQL replacement">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="comparison-table.css">
        <link rel="stylesheet" href="mdbook-admonish.css">
        <link rel="stylesheet" href="././mdbook-admonish.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="queries/queries.html"><strong aria-hidden="true">2.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="queries/pipelines.html"><strong aria-hidden="true">2.1.</strong> Pipelines</a></li><li class="chapter-item expanded "><a href="queries/functions.html"><strong aria-hidden="true">2.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="queries/tables.html"><strong aria-hidden="true">2.3.</strong> Tables</a></li><li class="chapter-item expanded "><a href="queries/syntax.html"><strong aria-hidden="true">2.4.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="queries/dialect_and_version.html"><strong aria-hidden="true">2.5.</strong> Dialect & Version</a></li></ol></li><li class="chapter-item expanded "><a href="transforms.html"><strong aria-hidden="true">3.</strong> Transforms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="transforms/aggregate.html"><strong aria-hidden="true">3.1.</strong> Aggregate</a></li><li class="chapter-item expanded "><a href="transforms/derive.html"><strong aria-hidden="true">3.2.</strong> Derive</a></li><li class="chapter-item expanded "><a href="transforms/filter.html"><strong aria-hidden="true">3.3.</strong> Filter</a></li><li class="chapter-item expanded "><a href="transforms/from.html"><strong aria-hidden="true">3.4.</strong> From</a></li><li class="chapter-item expanded "><a href="transforms/group.html"><strong aria-hidden="true">3.5.</strong> Group</a></li><li class="chapter-item expanded "><a href="transforms/join.html"><strong aria-hidden="true">3.6.</strong> Join</a></li><li class="chapter-item expanded "><a href="transforms/select.html"><strong aria-hidden="true">3.7.</strong> Select</a></li><li class="chapter-item expanded "><a href="transforms/sort.html"><strong aria-hidden="true">3.8.</strong> Sort</a></li><li class="chapter-item expanded "><a href="transforms/take.html"><strong aria-hidden="true">3.9.</strong> Take</a></li><li class="chapter-item expanded "><a href="transforms/window.html"><strong aria-hidden="true">3.10.</strong> Window</a></li></ol></li><li class="chapter-item expanded "><a href="language-features/index.html"><strong aria-hidden="true">4.</strong> Language features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language-features/coalesce.html"><strong aria-hidden="true">4.1.</strong> Coalesce</a></li><li class="chapter-item expanded "><a href="language-features/dates_and_times.html"><strong aria-hidden="true">4.2.</strong> Dates & Times</a></li><li class="chapter-item expanded "><a href="language-features/distinct.html"><strong aria-hidden="true">4.3.</strong> Distinct</a></li><li class="chapter-item expanded "><a href="language-features/f-strings.html"><strong aria-hidden="true">4.4.</strong> F-Strings</a></li><li class="chapter-item expanded "><a href="language-features/null.html"><strong aria-hidden="true">4.5.</strong> Null handling</a></li><li class="chapter-item expanded "><a href="language-features/ranges.html"><strong aria-hidden="true">4.6.</strong> Ranges</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Regex</div></li><li class="chapter-item expanded "><a href="language-features/s-strings.html"><strong aria-hidden="true">4.8.</strong> S-Strings</a></li><li class="chapter-item expanded "><a href="language-features/strings.html"><strong aria-hidden="true">4.9.</strong> Strings</a></li></ol></li><li class="chapter-item expanded "><a href="stdlib.html"><strong aria-hidden="true">5.</strong> Stdlib</a></li><li class="chapter-item expanded "><a href="bindings/index.html"><strong aria-hidden="true">6.</strong> Bindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bindings/java.html"><strong aria-hidden="true">6.1.</strong> Java</a></li><li class="chapter-item expanded "><a href="bindings/javascript.html"><strong aria-hidden="true">6.2.</strong> JavaScript</a></li><li class="chapter-item expanded "><a href="bindings/python.html"><strong aria-hidden="true">6.3.</strong> Python</a></li><li class="chapter-item expanded "><a href="bindings/rust.html"><strong aria-hidden="true">6.4.</strong> Rust</a></li></ol></li><li class="chapter-item expanded "><a href="integrations/index.html"><strong aria-hidden="true">7.</strong> Integrations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrations/dbt.html"><strong aria-hidden="true">7.1.</strong> dbt</a></li><li class="chapter-item expanded "><a href="integrations/jupyter.html"><strong aria-hidden="true">7.2.</strong> Jupyter</a></li><li class="chapter-item expanded "><a href="integrations/prefect.html"><strong aria-hidden="true">7.3.</strong> Prefect</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> VSCode</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Rill</div></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">8.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/variables.html"><strong aria-hidden="true">8.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="examples/list-equivalence.html"><strong aria-hidden="true">8.2.</strong> List equivalence</a></li><li class="chapter-item expanded "><a href="examples/cte.html"><strong aria-hidden="true">8.3.</strong> CTE (intermediate tables)</a></li><li class="chapter-item expanded "><a href="examples/sql-parameters.html"><strong aria-hidden="true">8.4.</strong> SQL parameters</a></li><li class="chapter-item expanded "><a href="examples/employees.html"><strong aria-hidden="true">8.5.</strong> Employees</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PRQL Language Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/prql/prql" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>PRQL is a modern language for transforming data — a simple, powerful, pipelined
SQL replacement. Like SQL, it’s readable, explicit and declarative. Unlike SQL,
it forms a logical pipeline of transformations, and supports abstractions such
as variables and functions. It can be used with any database that uses SQL,
since it transpiles to SQL.</p>
<p>Let’s get started with an example:</p>
<!-- TODO: make this onramp friendlier: https://github.com/prql/prql/issues/522 -->
<div class="comparison">
<div>
<h4 id="prql"><a class="header" href="#prql">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter start_date &gt; @2021-01-01               # Clear date syntax.
derive [                                      # `derive` adds columns / variables.
  gross_salary = salary + (tax ?? 0),         # Terse coalesce
  gross_cost = gross_salary + benefits_cost,  # Variables can use other variables.
]
filter gross_cost &gt; 0
group [title, country] (                      # `group` runs a pipeline over each group.
  aggregate [                                 # `aggregate` reduces each group to a row.
    average gross_salary,
    sum_gross_cost = sum gross_cost,          # `=` sets a column name.
  ]
)
filter sum_gross_cost &gt; 100000                # Identical syntax for SQL's `WHERE` &amp; `HAVING`.
derive [
  id = f&quot;{title}_{country}&quot;,                   # F-strings like python.
  db_version = s&quot;version()&quot;,                  # An S-string, which transpiles directly into SQL
]
sort [sum_gross_cost, -country]               # `-country` means descending order.
take 1..20                                    # Range expressions (also valid here as `take 20`).
</code></pre>
</div>
<div>
<h4 id="sql"><a class="header" href="#sql">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary + COALESCE(tax, 0)),
  SUM(salary + COALESCE(tax, 0) + benefits_cost) AS sum_gross_cost,
  CONCAT(title, '_', country) AS id,
  version() AS db_version
FROM
  employees
WHERE
  start_date &gt; DATE '2021-01-01'
  AND salary + COALESCE(tax, 0) + benefits_cost &gt; 0
GROUP BY
  title,
  country
HAVING
  SUM(salary + COALESCE(tax, 0) + benefits_cost) &gt; 100000
ORDER BY
  sum_gross_cost,
  country DESC
LIMIT
  20
</code></pre>
</div>
</div>
<p>As you can see, PRQL is a linear <strong>pipeline of transformations</strong> — each line of the
query is a transformation of the previous line’s result.</p>
<p>You can see that in SQL, operations do not follow one another, which makes it hard to compose larger queries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipelines"><a class="header" href="#pipelines">Pipelines</a></h1>
<h2 id="the-simplest-pipeline"><a class="header" href="#the-simplest-pipeline">The simplest pipeline</a></h2>
<p>The simplest pipeline is just:</p>
<div class="comparison">
<div>
<h4 id="prql-1"><a class="header" href="#prql-1">PRQL</a></h4>
<pre><code class="language-prql">from employees
</code></pre>
</div>
<div>
<h4 id="sql-1"><a class="header" href="#sql-1">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
</code></pre>
</div>
</div>
<h2 id="adding-transformations"><a class="header" href="#adding-transformations">Adding transformations</a></h2>
<p>We can add additional lines, each one transforms the result:</p>
<div class="comparison">
<div>
<h4 id="prql-2"><a class="header" href="#prql-2">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = (salary + payroll_tax)
</code></pre>
</div>
<div>
<h4 id="sql-2"><a class="header" href="#sql-2">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary
FROM
  employees
</code></pre>
</div>
</div>
<p>…and so on:</p>
<div class="comparison">
<div>
<h4 id="prql-3"><a class="header" href="#prql-3">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = (salary + payroll_tax)
sort gross_salary
</code></pre>
</div>
<div>
<h4 id="sql-3"><a class="header" href="#sql-3">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary
FROM
  employees
ORDER BY
  gross_salary
</code></pre>
</div>
</div>
<h2 id="compiling-to-sql"><a class="header" href="#compiling-to-sql">Compiling to SQL</a></h2>
<p>When compiling to SQL, the PRQL compiler will try to represent as many
transforms as possible with a single <code>SELECT</code> statement. When necessary it will
“overflow” using CTEs (common table expressions):</p>
<div class="comparison">
<div>
<h4 id="prql-4"><a class="header" href="#prql-4">PRQL</a></h4>
<pre><code class="language-prql">from e = employees
derive gross_salary = (salary + payroll_tax)
sort gross_salary
take 10
join d = department [dept_no]
select [e.name, gross_salary, d.name]
</code></pre>
</div>
<div>
<h4 id="sql-4"><a class="header" href="#sql-4">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    e.*,
    salary + payroll_tax AS gross_salary
  FROM
    employees AS e
  ORDER BY
    gross_salary
  LIMIT
    10
)
SELECT
  table_0.name,
  table_0.gross_salary,
  d.name
FROM
  table_0
  JOIN department AS d USING(dept_no)
</code></pre>
</div>
</div>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<p><a href="queries/./syntax.html">Syntax</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<!--
TODOs:
- Examples are a bit artificial — the interp is just "divide by 100" in one case!  -->
<p>Functions are a fundamental abstraction in PRQL — they allow us to run code in
many places that we’ve written once. This reduces the number of errors in our
code, makes our code more readable, and simplifies making changes.</p>
<p>Functions have two types of parameters:</p>
<ol>
<li>Positional parameters, which require an argument.</li>
<li>Named parameters, which optionally take an argument, otherwise using their
default value.</li>
</ol>
<p>So this function is named <code>celsius_of_fahrenheit</code> and has one parameter <code>temp</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-5"><a class="header" href="#prql-5">PRQL</a></h4>
<pre><code class="language-prql">func celsius_of_fahrenheit temp -&gt; (temp - 32) * 3

from cities
derive temp_c = (celsius_of_fahrenheit temp_f)
</code></pre>
</div>
<div>
<h4 id="sql-5"><a class="header" href="#sql-5">SQL</a></h4>
<pre><code class="language-sql">SELECT
  cities.*,
  (temp_f - 32) * 3 AS temp_c
FROM
  cities
</code></pre>
</div>
</div>
<p>This function is named <code>interp</code>, and has two positional parameters named
<code>higher</code> and <code>x</code>, and one named parameter named <code>lower</code> which takes a default
argument of <code>0</code>. It calculates the proportion of the distance that <code>x</code> is
between <code>lower</code> and <code>higher</code>.</p>
<div class="comparison">
<div>
<h4 id="prql-6"><a class="header" href="#prql-6">PRQL</a></h4>
<pre><code class="language-prql">func interp lower:0 higher x -&gt; (x - lower) / (higher - lower)

from students
derive [
  sat_proportion_1 = (interp 1600 sat_score),
  sat_proportion_2 = (interp lower:0 1600 sat_score),
]
</code></pre>
</div>
<div>
<h4 id="sql-6"><a class="header" href="#sql-6">SQL</a></h4>
<pre><code class="language-sql">SELECT
  students.*,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_1,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_2
FROM
  students
</code></pre>
</div>
</div>
<h2 id="piping"><a class="header" href="#piping">Piping</a></h2>
<p>Consistent with the principles of PRQL, it’s possible to pipe values into
functions, which makes composing many functions more readable. When piping a
value into a function, the value is passed as an argument to the final
positional parameter of the function. Here’s the same result as the examples
above with an alternative construction:</p>
<div class="comparison">
<div>
<h4 id="prql-7"><a class="header" href="#prql-7">PRQL</a></h4>
<pre><code class="language-prql">func interp lower:0 higher x -&gt; (x - lower) / (higher - lower)

from students
derive [
  sat_proportion_1 = (sat_score | interp 1600),
  sat_proportion_2 = (sat_score | interp lower:0 1600),
]
</code></pre>
</div>
<div>
<h4 id="sql-7"><a class="header" href="#sql-7">SQL</a></h4>
<pre><code class="language-sql">SELECT
  students.*,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_1,
  (sat_score - 0) / (1600 - 0) AS sat_proportion_2
FROM
  students
</code></pre>
</div>
</div>
<p>and</p>
<div class="comparison">
<div>
<h4 id="prql-8"><a class="header" href="#prql-8">PRQL</a></h4>
<pre><code class="language-prql">func celsius_of_fahrenheit temp -&gt; (temp - 32) * 3

from cities
derive temp_c = (temp_f | celsius_of_fahrenheit)
</code></pre>
</div>
<div>
<h4 id="sql-8"><a class="header" href="#sql-8">SQL</a></h4>
<pre><code class="language-sql">SELECT
  cities.*,
  (temp_f - 32) * 3 AS temp_c
FROM
  cities
</code></pre>
</div>
</div>
<p>We can combine a chain of functions, which makes logic more readable:</p>
<div class="comparison">
<div>
<h4 id="prql-9"><a class="header" href="#prql-9">PRQL</a></h4>
<pre><code class="language-prql">func celsius_of_fahrenheit temp -&gt; (temp - 32) * 3
func interp lower:0 higher x -&gt; (x - lower) / (higher - lower)

from kettles
derive boiling_proportion = (temp_c | celsius_of_fahrenheit | interp 100)
</code></pre>
</div>
<div>
<h4 id="sql-9"><a class="header" href="#sql-9">SQL</a></h4>
<pre><code class="language-sql">SELECT
  kettles.*,
  ((temp_c - 32) * 3 - 0) / (100 - 0) AS boiling_proportion
FROM
  kettles
</code></pre>
</div>
</div>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<h3 id="late-binding"><a class="header" href="#late-binding">Late binding</a></h3>
<p>Currently, functions require a binding to variables in scope; they can’t
late-bind to column names; so for example:</p>
<pre><code class="language-prql_no_test">func return price -&gt; (price - dividend) / price_yesterday
</code></pre>
<p>…isn’t yet a valid function, and instead would needs to be:</p>
<pre><code class="language-prql_no_test">func return price dividend price_yesterday -&gt;  (price - dividend) / (price_yesterday)
</code></pre>
<p>(which makes functions in this case not useful)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tables"><a class="header" href="#tables">Tables</a></h1>
<p>We can create a table — similar to a CTE in SQL — with <code>table</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-10"><a class="header" href="#prql-10">PRQL</a></h4>
<pre><code class="language-prql">table top_50 = (
  from employees
  sort salary
  take 50
  aggregate (sum salary)
)

from another_table      # Starts a new pipeline
</code></pre>
</div>
<div>
<h4 id="sql-10"><a class="header" href="#sql-10">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    employees.*
  FROM
    employees
  ORDER BY
    salary
  LIMIT
    50
), top_50 AS (
  SELECT
    SUM(salary)
  FROM
    table_0
)
SELECT
  another_table.*
FROM
  another_table
</code></pre>
</div>
</div>
<p>In PRQL <code>table</code>s are far less common than CTEs are in SQL, since a linear
series of CTEs can be represented with a single pipeline.</p>
<h2 id="roadmap-1"><a class="header" href="#roadmap-1">Roadmap</a></h2>
<p>Currently it’s not yet possible to have an
<a href="queries/./../language-features/s-strings.html">s-string</a> as a whole table. See
<a href="https://github.com/prql/prql/issues/376">#376</a> for more details.</p>
<!-- TODO: find an example that we can't currently represent with PRQL -->
<pre><code class="language-prql_no_test">table a = s&quot;&quot;&quot;
  SELECT *
  FROM employees
&quot;&quot;&quot;

from a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>A summary of PRQL syntax</p>
<!-- The `|` characters need to be escaped, and surrounded with tags rather than backticks -->
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Usage</th><th>Example</th></tr></thead><tbody>
<tr><td><code>|</code></td><td>Pipe</td><td><code>from employees | select first_name</code></td></tr>
<tr><td><code>=</code></td><td>Assigns &amp; Aliases</td><td><code>from e = employees</code> <br> <code>derive total = (sum salary)</code></td></tr>
<tr><td><code>:</code></td><td>Named args &amp; Parameters</td><td><code>interp lower:0 1600 sat_score</code></td></tr>
<tr><td><code>[]</code></td><td>List</td><td><code>select [id, amount]</code></td></tr>
<tr><td><code>()</code></td><td>Precedence</td><td><code>derive fahrenheit = (celsius - 32) * 1.8</code></td></tr>
<tr><td><code>#</code></td><td>Comment</td><td><code># A comment</code></td></tr>
<tr><td><code>@</code></td><td>Date &amp; times</td><td><code>@2021-01-01</code></td></tr>
<tr><td><code>==</code></td><td>Equality comparison</td><td><code>join s=salaries [s.emp_id == e.id]</code></td></tr>
<tr><td><code>-&gt;</code></td><td>Function definitions</td><td><code>func add a b -&gt; a + b</code></td></tr>
<tr><td><code>+</code>/<code>-</code></td><td>Sort order</td><td><code>sort [-amount, +date]</code></td></tr>
<tr><td><code>??</code></td><td>Coalesce</td><td><code>amount ?? 0</code></td></tr>
<tr><td><code>&lt;type&gt;</code></td><td>Annotations</td><td><code>@2021-01-01&lt;datetime&gt;</code></td></tr>
</tbody></table>
</div>
<h2 id="pipes"><a class="header" href="#pipes">Pipes</a></h2>
<p>Pipes — the connection between <a href="queries/../transforms.html">transforms</a> that make up a
pipeline — can be either line breaks or a pipe character (<code>|</code>).</p>
<p>In almost all situations, line-breaks pipe the result of a line’s transform into the transform on
the following line. For example, the <code>filter</code> transform operates on the result
of <code>from employees</code> (which is just the <code>employees</code> table), and the <code>select</code> transform operates on
the result of the <code>filter</code> transform.</p>
<div class="comparison">
<div>
<h4 id="prql-11"><a class="header" href="#prql-11">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter department == &quot;Product&quot;
select [first_name, last_name]
</code></pre>
</div>
<div>
<h4 id="sql-11"><a class="header" href="#sql-11">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
WHERE
  department = 'Product'
</code></pre>
</div>
</div>
<p>In the place of a line-break, it’s also possible to use the <code>|</code> character to
pipe results, such that this is equivalent:</p>
<div class="comparison">
<div>
<h4 id="prql-12"><a class="header" href="#prql-12">PRQL</a></h4>
<pre><code class="language-prql">from employees | filter department == &quot;Product&quot; | select [first_name, last_name]
</code></pre>
</div>
<div>
<h4 id="sql-12"><a class="header" href="#sql-12">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
WHERE
  department = 'Product'
</code></pre>
</div>
</div>
<p>A line-break doesn’t create a pipeline in a couple of cases:</p>
<ul>
<li>within a list (e.g. the <code>derive</code> examples below),</li>
<li>when the following line is a new statement, which starts with a keyword of
<code>func</code>, <code>table</code> or <code>from</code>.</li>
</ul>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>Lists are represented with <code>[]</code>, and can span multiple lines. A final trailing
comma is optional.</p>
<div class="comparison">
<div>
<h4 id="prql-13"><a class="header" href="#prql-13">PRQL</a></h4>
<pre><code class="language-prql">derive [x = 1, y = 2]
derive [
  a = x,
  b = y
]
derive [
  c = a,
  d = b,
]
</code></pre>
</div>
<div>
<h4 id="sql-13"><a class="header" href="#sql-13">SQL</a></h4>
<pre><code class="language-sql">SELECT
  1 AS x,
  2 AS y,
  1 AS a,
  2 AS b,
  1 AS c,
  2 AS d
</code></pre>
</div>
</div>
<p>Most transforms can take either a list or a single item, so these are
equivalent:</p>
<div class="comparison">
<div>
<h4 id="prql-14"><a class="header" href="#prql-14">PRQL</a></h4>
<pre><code class="language-prql">from employees
select [first_name]
</code></pre>
</div>
<div>
<h4 id="sql-14"><a class="header" href="#sql-14">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-15"><a class="header" href="#prql-15">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-15"><a class="header" href="#sql-15">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees
</code></pre>
</div>
</div>
<h2 id="parentheses"><a class="header" href="#parentheses">Parentheses</a></h2>
<p>Parentheses — <code>()</code> — are used to give precedence to inner expressions, as is the
case in almost all languages / math.</p>
<p>In particular, parentheses are used to nest pipelines for transforms such as
<code>group</code> and <code>window</code>, which take a pipeline. Here, the <code>aggregate</code> pipeline is
applied to each group of unique <code>title</code> and <code>country</code> values.</p>
<div class="comparison">
<div>
<h4 id="prql-16"><a class="header" href="#prql-16">PRQL</a></h4>
<pre><code class="language-prql">from employees
group [title, country] (
  aggregate [
    average salary,
    ct = count
  ]
)
</code></pre>
</div>
<div>
<h4 id="sql-16"><a class="header" href="#sql-16">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country
</code></pre>
</div>
</div>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Comments are represented by <code>#</code>. Currently only single line comments exist.</p>
<div class="comparison">
<div>
<h4 id="prql-17"><a class="header" href="#prql-17">PRQL</a></h4>
<pre><code class="language-prql">from employees  # Comment 1
# Comment 2
aggregate [average salary]
</code></pre>
</div>
<div>
<h4 id="sql-17"><a class="header" href="#sql-17">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees
</code></pre>
</div>
</div>
<h2 id="backticks"><a class="header" href="#backticks">Backticks</a></h2>
<p>To use identifiers that are otherwise invalid, surround them with backticks.
Depending on the dialect, these will remain as backticks or be converted to
double-quotes</p>
<div class="comparison">
<div>
<h4 id="prql-18"><a class="header" href="#prql-18">PRQL</a></h4>
<pre><code class="language-prql">prql dialect:mysql
from employees
select `first name`
</code></pre>
</div>
<div>
<h4 id="sql-18"><a class="header" href="#sql-18">SQL</a></h4>
<pre><code class="language-sql">SELECT
  `first name`
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-19"><a class="header" href="#prql-19">PRQL</a></h4>
<pre><code class="language-prql">prql dialect:postgres
from employees
select `first name`
</code></pre>
</div>
<div>
<h4 id="sql-19"><a class="header" href="#sql-19">SQL</a></h4>
<pre><code class="language-sql">SELECT
  &quot;first name&quot;
FROM
  employees
</code></pre>
</div>
</div>
<p>BigQuery also uses backticks to surround project &amp; dataset names (even if valid
identifiers) in the <code>SELECT</code> statement:</p>
<div class="comparison">
<div>
<h4 id="prql-20"><a class="header" href="#prql-20">PRQL</a></h4>
<pre><code class="language-prql">prql dialect:bigquery
from `project-foo.dataset.table`
join `project-bar.dataset.table` [col_bax]
</code></pre>
</div>
<div>
<h4 id="sql-20"><a class="header" href="#sql-20">SQL</a></h4>
<pre><code class="language-sql">SELECT
  `project-foo.dataset.table`.*,
  `project-bar.dataset.table`.*,
  col_bax
FROM
  `project-foo.dataset.table`
  JOIN `project-bar.dataset.table` USING(col_bax)
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-header-dialect--version"><a class="header" href="#query-header-dialect--version">Query header: Dialect &amp; Version</a></h1>
<h2 id="dialect"><a class="header" href="#dialect">Dialect</a></h2>
<p>PRQL allows specifying a dialect at the top of the query, which allows PRQL to
compile to a database-specific SQL flavor.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<div class="comparison">
<div>
<h4 id="prql-21"><a class="header" href="#prql-21">PRQL</a></h4>
<pre><code class="language-prql">prql dialect:postgres

from employees
sort age
take 10
</code></pre>
</div>
<div>
<h4 id="sql-21"><a class="header" href="#sql-21">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  age
LIMIT
  10
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-22"><a class="header" href="#prql-22">PRQL</a></h4>
<pre><code class="language-prql">prql dialect:mssql

from employees
sort age
take 10
</code></pre>
</div>
<div>
<h4 id="sql-22"><a class="header" href="#sql-22">SQL</a></h4>
<pre><code class="language-sql">SELECT
  TOP (10) employees.*
FROM
  employees
ORDER BY
  age
</code></pre>
</div>
</div>
<h3 id="supported-dialects"><a class="header" href="#supported-dialects">Supported dialects</a></h3>
<blockquote>
<p>Note that dialect support is <em>very</em> early — most differences are not
implemented, and most dialects’ implementations are identical to <code>generic</code>’s.
Contributions are very welcome.</p>
</blockquote>
<ul>
<li><code>ansi</code></li>
<li><code>bigquery</code></li>
<li><code>clickhouse</code></li>
<li><code>generic</code></li>
<li><code>hive</code></li>
<li><code>mssql</code></li>
<li><code>mysql</code></li>
<li><code>postgres</code></li>
<li><code>sqlite</code></li>
<li><code>snowflake</code></li>
</ul>
<h2 id="version"><a class="header" href="#version">Version</a></h2>
<p>PRQL allows specifying a version of the language in the PRQL header, like:</p>
<div class="comparison">
<div>
<h4 id="prql-23"><a class="header" href="#prql-23">PRQL</a></h4>
<pre><code class="language-prql">prql version:1

from employees
</code></pre>
</div>
<div>
<h4 id="sql-23"><a class="header" href="#sql-23">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
</code></pre>
</div>
</div>
<p>When the functionality is implemented, it will allow the language to evolve
without breaking existing queries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transforms"><a class="header" href="#transforms">Transforms</a></h1>
<p>PRQL queries are a pipeline of transformations (“transforms”), where each transform takes
the previous result and adjusts it in some way, before passing it onto to the
next transform.</p>
<p>Because PRQL focuses on modularity, we have far fewer transforms than SQL, each
one fulfilling a specific purpose. That’s often referred to as “orthogonality”.</p>
<p>These are the currently available transforms:</p>
<div class="table-wrapper"><table><thead><tr><th>Transform</th><th>Purpose</th><th>SQL Equivalent</th></tr></thead><tbody>
<tr><td><a href="./transforms/from.html"><strong><code>from</code></strong></a></td><td>Starts from a table</td><td><code>FROM</code></td></tr>
<tr><td><a href="./transforms/derive.html"><strong><code>derive</code></strong></a></td><td>Computes new columns</td><td><code>SELECT *, ... AS ...</code></td></tr>
<tr><td><a href="./transforms/select.html"><strong><code>select</code></strong></a></td><td>Picks &amp; computes columns</td><td><code>SELECT ... AS ...</code></td></tr>
<tr><td><a href="./transforms/filter.html"><strong><code>filter</code></strong></a></td><td>Picks rows based on their values</td><td><code>WHERE</code>, <code>HAVING</code>,<code>QUALIFY</code></td></tr>
<tr><td><a href="./transforms/sort.html"><strong><code>sort</code></strong></a></td><td>Orders rows based on the values of columns</td><td><code>ORDER BY</code></td></tr>
<tr><td><a href="./transforms/join.html"><strong><code>join</code></strong></a></td><td>Adds columns from another table, matching rows based on a condition</td><td><code>JOIN</code></td></tr>
<tr><td><a href="./transforms/take.html"><strong><code>take</code></strong></a></td><td>Picks rows based on their position</td><td><code>TOP</code>, <code>LIMIT</code>, <code>OFFSET</code></td></tr>
<tr><td><a href="./transforms/group.html"><strong><code>group</code></strong></a></td><td>Partitions rows into groups and applies a pipeline to each of them</td><td><code>GROUP BY</code>, <code>PARTITION BY</code></td></tr>
<tr><td><a href="./transforms/aggregate.html"><strong><code>aggregate</code></strong></a></td><td>Summarizes many rows into one row</td><td><code>SELECT foo(...)</code></td></tr>
<tr><td><a href="./transforms/window.html"><strong><code>window</code></strong></a></td><td>Applies a pipeline to overlapping segments of rows</td><td><code>OVER</code>, <code>ROWS</code>, <code>RANGE</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h1>
<p>Summarizes many rows into one row.</p>
<p>When applied:</p>
<ul>
<li>without <code>group</code>, it produces one row from the whole table,</li>
<li>within a <code>group</code> pipeline, it produces one row from each group.</li>
</ul>
<pre><code class="language-prql_no_test">aggregate [{expression or assign operations}]
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-24"><a class="header" href="#prql-24">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate [
  average salary,
  ct = count
]
</code></pre>
</div>
<div>
<h4 id="sql-24"><a class="header" href="#sql-24">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-25"><a class="header" href="#prql-25">PRQL</a></h4>
<pre><code class="language-prql">from employees
group [title, country] (
  aggregate [
    average salary,
    ct = count
  ]
)
</code></pre>
</div>
<div>
<h4 id="sql-25"><a class="header" href="#sql-25">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive"><a class="header" href="#derive">Derive</a></h1>
<p>Computes one or more new columns.</p>
<pre><code class="language-prql_no_test">derive [{new_name} = {expression}]
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-26"><a class="header" href="#prql-26">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = salary + payroll_tax
</code></pre>
</div>
<div>
<h4 id="sql-26"><a class="header" href="#sql-26">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-27"><a class="header" href="#prql-27">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive [
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost
]
</code></pre>
</div>
<div>
<h4 id="sql-27"><a class="header" href="#sql-27">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary,
  salary + payroll_tax + benefits_cost AS gross_cost
FROM
  employees
</code></pre>
</div>
</div>
<p><code>derive</code> generally computes a column from existing columns, but can also take a
literal in which case it can begin a pipeline without a <code>from</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-28"><a class="header" href="#prql-28">PRQL</a></h4>
<pre><code class="language-prql">derive x = 5
</code></pre>
</div>
<div>
<h4 id="sql-28"><a class="header" href="#sql-28">SQL</a></h4>
<pre><code class="language-sql">SELECT
  5 AS x
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filter"><a class="header" href="#filter">Filter</a></h1>
<p>Picks rows based on their values.</p>
<pre><code class="language-prql_no_test">filter {boolean_expression}
</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-29"><a class="header" href="#prql-29">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter age &gt; 25
</code></pre>
</div>
<div>
<h4 id="sql-29"><a class="header" href="#sql-29">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
WHERE
  age &gt; 25
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-30"><a class="header" href="#prql-30">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter (age | in 25..40)
</code></pre>
</div>
<div>
<h4 id="sql-30"><a class="header" href="#sql-30">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
WHERE
  age BETWEEN 25
  AND 40
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from"><a class="header" href="#from">From</a></h1>
<p>Specifies a data source.</p>
<pre><code class="language-prql_no_test">from {table_reference}
</code></pre>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-31"><a class="header" href="#prql-31">PRQL</a></h4>
<pre><code class="language-prql">from employees
</code></pre>
</div>
<div>
<h4 id="sql-31"><a class="header" href="#sql-31">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
</code></pre>
</div>
</div>
<p>To introduce an alias, use an assign expression:</p>
<div class="comparison">
<div>
<h4 id="prql-32"><a class="header" href="#prql-32">PRQL</a></h4>
<pre><code class="language-prql">from e = employees
select e.first_name
</code></pre>
</div>
<div>
<h4 id="sql-32"><a class="header" href="#sql-32">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees AS e
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="group"><a class="header" href="#group">Group</a></h1>
<p>Partitions the rows into groups and applies a pipeline to each of the groups.</p>
<pre><code class="language-prql_no_test">group [{key_columns}] {pipeline}
</code></pre>
<p>The partitioning of groups are determined by the <code>key_column</code>s (first argument).</p>
<p>The most conventional use of <code>group</code> is with <code>aggregate</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-33"><a class="header" href="#prql-33">PRQL</a></h4>
<pre><code class="language-prql">from employees
group [title, country] (
  aggregate [
    average salary,
    ct = count
  ]
)
</code></pre>
</div>
<div>
<h4 id="sql-33"><a class="header" href="#sql-33">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  COUNT(*) AS ct
FROM
  employees
GROUP BY
  title,
  country
</code></pre>
</div>
</div>
<p>In concept, a transform in context of a <code>group</code> does the same transformation to the group as
it would to the table — for example finding the employee who joined first across
the whole table:</p>
<div class="comparison">
<div>
<h4 id="prql-34"><a class="header" href="#prql-34">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort join_date
take 1
</code></pre>
</div>
<div>
<h4 id="sql-34"><a class="header" href="#sql-34">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  join_date
LIMIT
  1
</code></pre>
</div>
</div>
<p>To find the employee who joined first in each department, it’s exactly the
same pipeline, but within a <code>group</code> expression:</p>
<div class="comparison">
<div>
<h4 id="prql-35"><a class="header" href="#prql-35">PRQL</a></h4>
<pre><code class="language-prql">from employees
group role (
  sort join_date  # taken from above
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-35"><a class="header" href="#sql-35">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    employees.*,
    ROW_NUMBER() OVER (
      PARTITION BY role
      ORDER BY
        join_date
    ) AS _rn_82
  FROM
    employees
)
SELECT
  table_0.*
FROM
  table_0
WHERE
  _rn_82 &lt;= 1
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join"><a class="header" href="#join">Join</a></h1>
<p>Adds columns from another table, matching rows based on a condition.</p>
<pre><code class="language-prql_no_test">join side:{inner|left|right|full} {table} {[conditions]}
</code></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li><code>side</code> decides which rows to include. Defaults to <code>inner</code></li>
<li>Table reference</li>
<li>List of conditions
<ul>
<li>If all terms are column identifiers, this will compile to <code>USING(...)</code>. In
this case, both tables must contain specified columns. The result will only
contain one column for each specified column.</li>
</ul>
</li>
</ul>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-36"><a class="header" href="#prql-36">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left positions [id==employee_id]
</code></pre>
</div>
<div>
<h4 id="sql-36"><a class="header" href="#sql-36">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*
FROM
  employees
  LEFT JOIN positions ON id = employee_id
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-37"><a class="header" href="#prql-37">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:full positions [emp_no]
</code></pre>
</div>
<div>
<h4 id="sql-37"><a class="header" href="#sql-37">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  positions.*,
  emp_no
FROM
  employees FULL
  JOIN positions USING(emp_no)
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-38"><a class="header" href="#prql-38">PRQL</a></h4>
<pre><code class="language-prql">from employees
join side:left p=positions [id==employee_id]
</code></pre>
</div>
<div>
<h4 id="sql-38"><a class="header" href="#sql-38">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  p.*
FROM
  employees
  LEFT JOIN positions AS p ON id = employee_id
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>Picks and computes columns.</p>
<pre><code class="language-prql_no_test">select [{assign_expression}]
</code></pre>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-39"><a class="header" href="#prql-39">PRQL</a></h4>
<pre><code class="language-prql">from employees
select first_name
</code></pre>
</div>
<div>
<h4 id="sql-39"><a class="header" href="#sql-39">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-40"><a class="header" href="#prql-40">PRQL</a></h4>
<pre><code class="language-prql">from employees
select [first_name, last_name]
</code></pre>
</div>
<div>
<h4 id="sql-40"><a class="header" href="#sql-40">SQL</a></h4>
<pre><code class="language-sql">SELECT
  first_name,
  last_name
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-41"><a class="header" href="#prql-41">PRQL</a></h4>
<pre><code class="language-prql">from employees
select name = f&quot;{first_name} {last_name}&quot;
</code></pre>
</div>
<div>
<h4 id="sql-41"><a class="header" href="#sql-41">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-42"><a class="header" href="#prql-42">PRQL</a></h4>
<pre><code class="language-prql">from employees
select [
  name = f&quot;{first_name} {last_name}&quot;,
  age_eoy = dob - @2022-12-31,
]
</code></pre>
</div>
<div>
<h4 id="sql-42"><a class="header" href="#sql-42">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS name,
  dob - DATE '2022-12-31' AS age_eoy
FROM
  employees
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sort"><a class="header" href="#sort">Sort</a></h1>
<p>Orders rows based on the values of one or more columns.</p>
<pre><code class="language-prql_no_test">sort [{direction}{column}]
</code></pre>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<ul>
<li>One column or a list of columns to sort by</li>
<li>Each column can be prefixed with:
<ul>
<li><code>+</code>, for ascending order, the default</li>
<li><code>-</code>, for descending order</li>
</ul>
</li>
<li>When using prefixes, make sure to wrap columns in a list. Otherwise, <code>sort -column</code> is interpreted as subtraction between <code>sort</code> and <code>column</code>.</li>
</ul>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-43"><a class="header" href="#prql-43">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort age
</code></pre>
</div>
<div>
<h4 id="sql-43"><a class="header" href="#sql-43">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  age
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-44"><a class="header" href="#prql-44">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort [-age]
</code></pre>
</div>
<div>
<h4 id="sql-44"><a class="header" href="#sql-44">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  age DESC
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-45"><a class="header" href="#prql-45">PRQL</a></h4>
<pre><code class="language-prql">from employees
sort [age, -tenure, +salary]
</code></pre>
</div>
<div>
<h4 id="sql-45"><a class="header" href="#sql-45">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
ORDER BY
  age,
  tenure DESC,
  salary
</code></pre>
</div>
</div>
<h2 id="roadmap-2"><a class="header" href="#roadmap-2">Roadmap</a></h2>
<p>Currently <code>sort</code> does not accept expressions:</p>
<pre><code class="language-prql_no_test">from employees
sort [s&quot;substr({first_name}, 2, 5)&quot;]  # Currently will fail
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="take"><a class="header" href="#take">Take</a></h1>
<p>Picks rows based on their position.</p>
<pre><code class="language-prql_no_test">take {n|range}
</code></pre>
<p>See <a href="transforms/../language-features/ranges.html">Ranges</a> for more details on how ranges
work.</p>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<div class="comparison">
<div>
<h4 id="prql-46"><a class="header" href="#prql-46">PRQL</a></h4>
<pre><code class="language-prql">from employees
take 10
</code></pre>
</div>
<div>
<h4 id="sql-46"><a class="header" href="#sql-46">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
LIMIT
  10
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-47"><a class="header" href="#prql-47">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort [-value, date]
take 101..110
</code></pre>
</div>
<div>
<h4 id="sql-47"><a class="header" href="#sql-47">SQL</a></h4>
<pre><code class="language-sql">SELECT
  orders.*
FROM
  orders
ORDER BY
  value DESC,
  date
LIMIT
  10 OFFSET 100
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window"><a class="header" href="#window">Window</a></h1>
<p>Applies a pipeline to segments of rows, producing one output value for every
input value.</p>
<pre><code class="language-prql_no_test">window rows:{range} range:{range} expanding:false rolling:0 {pipeline}
</code></pre>
<p>For each row, the segment over which the pipeline is applied is determined by
one of:</p>
<ul>
<li><code>rows</code>, which takes a range of rows relative to the current row position.
<ul>
<li><code>0</code> references the current row.</li>
</ul>
</li>
<li><code>range</code>, which takes a range of values relative to current row value.</li>
</ul>
<p>The bounds of the range are inclusive. If a bound is omitted, the segment will
extend until the edge of the table or group.</p>
<!-- TODO: rows vs range example, with visualization -->
<p>For ease of use, there are two flags that override <code>rows</code> or <code>range</code>:</p>
<ul>
<li><code>expanding:true</code> is an alias for <code>rows:..0</code>. A sum using this window is also
known as “cumulative sum”.</li>
<li><code>rolling:n</code> is an alias for <code>row:(-n+1)..0</code>, where <code>n</code> is an integer. This
will include <code>n</code> last values, including current row. An average using this
window is also knows as a Simple Moving Average.</li>
</ul>
<p>Some examples:</p>
<div class="table-wrapper"><table><thead><tr><th>Expression</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>rows:0..2</code></td><td>current row plus two following</td></tr>
<tr><td><code>rows:-2..0</code></td><td>two preceding rows plus current row</td></tr>
<tr><td><code>rolling:3</code></td><td>(same as previous)</td></tr>
<tr><td><code>rows:-2..4</code></td><td>two preceding rows plus current row plus four following rows</td></tr>
<tr><td><code>rows:..0</code></td><td>all rows from the start of the table up to &amp; including current row</td></tr>
<tr><td><code>expanding:true</code></td><td>(same as previous)</td></tr>
<tr><td><code>rows:0..</code></td><td>current row and all following rows until the end of the table</td></tr>
<tr><td><code>rows:..</code></td><td>all rows, which same as not having window at all</td></tr>
</tbody></table>
</div>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<div class="comparison">
<div>
<h4 id="prql-48"><a class="header" href="#prql-48">PRQL</a></h4>
<pre><code class="language-prql">from employees
group employee_id (
  sort month
  window rolling:12 (
    derive [trail_12_m_comp = sum paycheck]
  )
)
</code></pre>
</div>
<div>
<h4 id="sql-48"><a class="header" href="#sql-48">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  SUM(paycheck) OVER (
    PARTITION BY employee_id
    ORDER BY
      month ROWS BETWEEN 11 PRECEDING
      AND CURRENT ROW
  ) AS trail_12_m_comp
FROM
  employees
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-49"><a class="header" href="#prql-49">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort day
window rows:-3..3 (
  derive [centered_weekly_average = average value]
)
group [order_month] (
  sort day
  window expanding:true (
    derive [monthly_running_total = sum value]
  )
)
</code></pre>
</div>
<div>
<h4 id="sql-49"><a class="header" href="#sql-49">SQL</a></h4>
<pre><code class="language-sql">SELECT
  orders.*,
  AVG(value) OVER (
    ORDER BY
      day ROWS BETWEEN 3 PRECEDING
      AND 3 FOLLOWING
  ) AS centered_weekly_average,
  SUM(value) OVER (
    PARTITION BY order_month
    ORDER BY
      day ROWS BETWEEN UNBOUNDED PRECEDING
      AND CURRENT ROW
  ) AS monthly_running_total
FROM
  orders
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-features"><a class="header" href="#language-features">Language Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coalesce"><a class="header" href="#coalesce">Coalesce</a></h1>
<p>We can coalesce values with an <code>??</code> operator. Coalescing takes either the first
value or, if that value is null, the second value.</p>
<div class="comparison">
<div>
<h4 id="prql-50"><a class="header" href="#prql-50">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive amount ?? 0
</code></pre>
</div>
<div>
<h4 id="sql-50"><a class="header" href="#sql-50">SQL</a></h4>
<pre><code class="language-sql">SELECT
  orders.*,
  COALESCE(amount, 0)
FROM
  orders
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dates--times"><a class="header" href="#dates--times">Dates &amp; Times</a></h1>
<p>PRQL uses <code>@</code> followed by a string to represent dates &amp; times. This is less
verbose than SQL’s approach of <code>TIMESTAMP '2004-10-19 10:23:54'</code> and more
explicit than SQL’s implicit option of just using a string <code>'2004-10-19 10:23:54'</code>.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="language-features/dates_and_times.html#admonition-note"></a></p>
</div>
<div>
<p>Currently PRQL passes strings which can be compiled straight through to the
database, and so many compatible formats string may work, but we may refine this
in the future to aid in compatibility across databases. We’ll always support the
canonical <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> format described below.</p>
</div>
</div>
<h2 id="dates"><a class="header" href="#dates">Dates</a></h2>
<p>Dates are represented by <code>@{yyyy-mm-dd}</code> — a <code>@</code> followed by the
date format.</p>
<div class="comparison">
<div>
<h4 id="prql-51"><a class="header" href="#prql-51">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive age_at_year_end = (@2022-12-31 - dob)
</code></pre>
</div>
<div>
<h4 id="sql-51"><a class="header" href="#sql-51">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  DATE '2022-12-31' - dob AS age_at_year_end
FROM
  employees
</code></pre>
</div>
</div>
<h2 id="times"><a class="header" href="#times">Times</a></h2>
<p>Times are represented by <code>@{HH:mm:ss.SSS±Z}</code> with any parts not supplied being
rounded to zero, including the timezone, which is represented by <code>+HH:mm</code>,
<code>-HH:mm</code> or <code>Z</code>. This is consistent with the ISO8601 time format.</p>
<div class="comparison">
<div>
<h4 id="prql-52"><a class="header" href="#prql-52">PRQL</a></h4>
<pre><code class="language-prql">from orders
derive should_have_shipped_today = (order_time &lt; @08:30)
</code></pre>
</div>
<div>
<h4 id="sql-52"><a class="header" href="#sql-52">SQL</a></h4>
<pre><code class="language-sql">SELECT
  orders.*,
  order_time &lt; TIME '08:30' AS should_have_shipped_today
FROM
  orders
</code></pre>
</div>
</div>
<h2 id="timestamps"><a class="header" href="#timestamps">Timestamps</a></h2>
<p>Timestamps are represented by <code>@{yyyy-mm-ddTHH:mm:ss.SSS±Z}</code> /
<code>@{date}T{time}</code>, with any time parts not supplied being rounded to zero,
including the timezone, which is represented by <code>+HH:mm</code>, <code>-HH:mm</code> or <code>Z</code>. This
is <code>@</code> followed by the ISO8601 datetime format, which uses <code>T</code> to separate date &amp;
time.</p>
<div class="comparison">
<div>
<h4 id="prql-53"><a class="header" href="#prql-53">PRQL</a></h4>
<pre><code class="language-prql">derive first_prql_commit = @2020-01-01T13:19:55-0800
</code></pre>
</div>
<div>
<h4 id="sql-53"><a class="header" href="#sql-53">SQL</a></h4>
<pre><code class="language-sql">SELECT
  TIMESTAMP '2020-01-01T13:19:55-0800' AS first_prql_commit
</code></pre>
</div>
</div>
<h2 id="intervals"><a class="header" href="#intervals">Intervals</a></h2>
<p>Intervals are represented by <code>{N}{periods}</code>, such as <code>2years</code> or <code>10minutes</code>,
without a space.</p>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="language-features/dates_and_times.html#admonition-note-1"></a></p>
</div>
<div>
<p>These aren’t the same as ISO8601, because we evaluated <code>P3Y6M4DT12H30M5S</code> to
be difficult to understand, but we could support a simplified form if there’s
demand for it. We don’t currently support compound expressions, for example
<code>2years10months</code>, but most DBs will allow <code>2years + 10months</code>. Please raise an
issue if this is inconvenient.</p>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-54"><a class="header" href="#prql-54">PRQL</a></h4>
<pre><code class="language-prql">from projects
derive first_check_in = start + 10days
</code></pre>
</div>
<div>
<h4 id="sql-54"><a class="header" href="#sql-54">SQL</a></h4>
<pre><code class="language-sql">SELECT
  projects.*,
  start + INTERVAL 10 DAY AS first_check_in
FROM
  projects
</code></pre>
</div>
</div>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<p>Here’s a fuller list of examples:</p>
<ul>
<li><code>@20221231</code> is forbidden — it must contain full punctuation (<code>-</code> and <code>:</code>),</li>
<li><code>@2022-12-31</code> is a date</li>
<li><code>@2022-12</code> or <code>@2022</code> are forbidden — SQL can’t express a month, only a date</li>
<li><code>@16:54:32.123456</code> is a time</li>
<li><code>@16:54:32</code>, <code>@16:54</code>, <code>@16</code> are all allowed, expressing <code>@16:54:32.000000</code>, <code>@16:54:00.000000</code>, <code>@16:00:00.000000</code> respectively</li>
<li><code>@2022-12-31T16:54:32.123456</code> is a timestamp without timezone</li>
<li><code>@2022-12-31T16:54:32.123456Z</code> is a timestamp in UTC</li>
<li><code>@2022-12-31T16:54+02</code> is timestamp in UTC+2</li>
<li><code>@2022-12-31T16:54+02:00</code> and <code>@2022-12-31T16:54+02</code> are datetimes in UTC+2</li>
<li><code>@16:54+02</code> is forbidden — time is always local, so it cannot have a timezone</li>
<li><code>@2022-12-31+02</code> is forbidden — date is always local, so it cannot have a timezone</li>
</ul>
<h2 id="roadmap-3"><a class="header" href="#roadmap-3">Roadmap</a></h2>
<h3 id="datetimes"><a class="header" href="#datetimes">Datetimes</a></h3>
<p>Datetimes are supported by some databases (e.g. MySql, BigQuery) in addition to
timestamps. When we have type annotations, these will be represented by a
timestamp annotated as a datetime:</p>
<pre><code class="language-prql_no_test">derive pi_day = @2017-03-14T15:09:26.535898&lt;datetime&gt;
</code></pre>
<p>These are some examples we can then add:</p>
<ul>
<li><code>@2022-12-31T16:54&lt;datetime&gt;</code> is datetime without timezone</li>
<li><code>@2022-12-31&lt;datetime&gt;</code> is forbidden — datetime must specify time</li>
<li><code>@16:54&lt;datetime&gt;</code> is forbidden — datetime must specify date</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distinct"><a class="header" href="#distinct">Distinct</a></h1>
<p>PRQL doesn’t have a specific <code>distinct</code> keyword. Instead, use <code>group</code> and <code>take 1</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-55"><a class="header" href="#prql-55">PRQL</a></h4>
<pre><code class="language-prql">from employees
select department
group department (
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-55"><a class="header" href="#sql-55">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DISTINCT department
FROM
  employees
</code></pre>
</div>
</div>
<p>This also works without a linebreak:</p>
<div class="comparison">
<div>
<h4 id="prql-56"><a class="header" href="#prql-56">PRQL</a></h4>
<pre><code class="language-prql">from employees
select department
group department (take 1)
</code></pre>
</div>
<div>
<h4 id="sql-56"><a class="header" href="#sql-56">SQL</a></h4>
<pre><code class="language-sql">SELECT
  DISTINCT department
FROM
  employees
</code></pre>
</div>
</div>
<h2 id="selecting-from-each-group"><a class="header" href="#selecting-from-each-group">Selecting from each group</a></h2>
<p>We are be able to <a href="https://stackoverflow.com/questions/3800551/select-first-row-in-each-group-by-group">select a single row from each
group</a>
by combining <code>group</code> and <code>sort</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-57"><a class="header" href="#prql-57">PRQL</a></h4>
<pre><code class="language-prql"># youngest employee from each department
from employees
group department (
  sort age
  take 1
)
</code></pre>
</div>
<div>
<h4 id="sql-57"><a class="header" href="#sql-57">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    employees.*,
    ROW_NUMBER() OVER (
      PARTITION BY department
      ORDER BY
        age
    ) AS _rn_82
  FROM
    employees
)
SELECT
  table_0.*
FROM
  table_0
WHERE
  _rn_82 &lt;= 1
</code></pre>
</div>
</div>
<h2 id="roadmap-4"><a class="header" href="#roadmap-4">Roadmap</a></h2>
<p>When using Postgres dialect, we are planning to compile:</p>
<pre><code class="language-prql_no_test"># youngest employee from each department
from employees
group department (
  sort age
  take 1
)
</code></pre>
<p>… to …</p>
<pre><code class="language-sql">SELECT DISTINCT ON (department) *
FROM employees
ORDER BY department, age
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f-strings"><a class="header" href="#f-strings">F-Strings</a></h1>
<p>f-strings are a readable approach to building new strings from existing strings.
Currently PRQL supports this for concatenating strings:</p>
<div class="comparison">
<div>
<h4 id="prql-58"><a class="header" href="#prql-58">PRQL</a></h4>
<pre><code class="language-prql">from employees
select full_name = f&quot;{first_name} {last_name}&quot;
</code></pre>
</div>
<div>
<h4 id="sql-58"><a class="header" href="#sql-58">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(first_name, ' ', last_name) AS full_name
FROM
  employees
</code></pre>
</div>
</div>
<p>This can be much easier to read for longer strings, relative to the SQL approach:</p>
<div class="comparison">
<div>
<h4 id="prql-59"><a class="header" href="#prql-59">PRQL</a></h4>
<pre><code class="language-prql">from web
select url = f&quot;http{tls}://www.{domain}.{tld}/{page}&quot;
</code></pre>
</div>
<div>
<h4 id="sql-59"><a class="header" href="#sql-59">SQL</a></h4>
<pre><code class="language-sql">SELECT
  CONCAT(
    'http',
    tls,
    '://www.',
    domain,
    '.',
    tld,
    '/',
    page
  ) AS url
FROM
  web
</code></pre>
</div>
</div>
<h2 id="roadmap-5"><a class="header" href="#roadmap-5">Roadmap</a></h2>
<p>In the future, f-strings may incorporate string formatting such as datetimes,
numbers, and padding. If there’s a feature that would be helpful, please <a href="https://github.com/prql/prql/issues/new/">post
an issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-handling"><a class="header" href="#null-handling">Null handling</a></h1>
<p>SQL has an unconventional way of handling <code>NULL</code> values, since it treats them as
unknown values. As a result, in SQL:</p>
<ul>
<li><code>NULL</code> is not a value indicating a missing entry, but a placeholder for anything possible,</li>
<li><code>NULL = NULL</code> evaluates to <code>NULL</code>, since one cannot know if one unknown is equal to another unknown,</li>
<li><code>NULL &lt;&gt; NULL</code> evaluates to <code>NULL</code>, using same logic,</li>
<li>to check if a value is <code>NULL</code>, SQL introduces <code>IS NULL</code> and <code>IS NOT NULL</code> operators,</li>
<li><code>DISTINCT column</code> may return multiple <code>NULL</code> values.</li>
</ul>
<p>For more information, check out the <a href="https://www.postgresql.org/docs/current/functions-comparison.html">Postgres documentation</a>.</p>
<p>PRQL, on the other hand, treats <code>null</code> as a value, which means that:</p>
<ul>
<li><code>null == null</code> evaluates to <code>true</code>,</li>
<li><code>null != null</code> evaluates to <code>false</code>,</li>
<li>distinct column cannot contain multiple <code>null</code> values.</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-60"><a class="header" href="#prql-60">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter first_name == null
filter null != last_name
</code></pre>
</div>
<div>
<h4 id="sql-60"><a class="header" href="#sql-60">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
WHERE
  first_name IS NULL
  AND last_name IS NOT NULL
</code></pre>
</div>
</div>
<p>Note that PRQL doesn’t change how <code>NULL</code> is compared between columns, for
example in joins. (PRQL compiles to SQL and so can’t change the behavior of the
database).</p>
<p>For more context or to provide feedback check out the discussion on
<a href="https://github.com/prql/prql/issues/99">issue #99</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranges"><a class="header" href="#ranges">Ranges</a></h1>
<p>PRQL has a concise range syntax <code>start..end</code>.</p>
<p>This can be used in filters with the <code>in</code> function, with any type of literal,
including dates:</p>
<div class="comparison">
<div>
<h4 id="prql-61"><a class="header" href="#prql-61">PRQL</a></h4>
<pre><code class="language-prql">from events
filter (date | in @1776-07-04..@1787-09-17)
filter (magnitude | in 50..100)
</code></pre>
</div>
<div>
<h4 id="sql-61"><a class="header" href="#sql-61">SQL</a></h4>
<pre><code class="language-sql">SELECT
  events.*
FROM
  events
WHERE
  date BETWEEN DATE '1776-07-04'
  AND DATE '1787-09-17'
  AND magnitude BETWEEN 50
  AND 100
</code></pre>
</div>
</div>
<p>Like in SQL, ranges are inclusive.</p>
<p>As discussed in the <a href="language-features/../transforms/take.html">take</a> docs, ranges can also be used
in <code>take</code>:</p>
<div class="comparison">
<div>
<h4 id="prql-62"><a class="header" href="#prql-62">PRQL</a></h4>
<pre><code class="language-prql">from orders
sort [-value, date]
take 101..110
</code></pre>
</div>
<div>
<h4 id="sql-62"><a class="header" href="#sql-62">SQL</a></h4>
<pre><code class="language-sql">SELECT
  orders.*
FROM
  orders
ORDER BY
  value DESC,
  date
LIMIT
  10 OFFSET 100
</code></pre>
</div>
</div>
<h2 id="roadmap-6"><a class="header" href="#roadmap-6">Roadmap</a></h2>
<p>We’d like to use this for more like whether an object is in an array or list literal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-strings"><a class="header" href="#s-strings">S-Strings</a></h1>
<p>An s-string inserts SQL directly, as an escape hatch when there’s something that PRQL
doesn’t yet implement. For example, there’s no <code>version()</code> function in SQL that
returns the Postgres version, so if we want to use that, we use an s-string:</p>
<div class="comparison">
<div>
<h4 id="prql-63"><a class="header" href="#prql-63">PRQL</a></h4>
<pre><code class="language-prql">derive db_version = s&quot;version()&quot;
</code></pre>
</div>
<div>
<h4 id="sql-63"><a class="header" href="#sql-63">SQL</a></h4>
<pre><code class="language-sql">SELECT
  version() AS db_version
</code></pre>
</div>
</div>
<p>We can embed columns in an s-string using braces. For example, PRQL’s standard
library defines the <code>average</code> function as:</p>
<pre><code class="language-prql_no_test">func average column -&gt; s&quot;AVG({column})&quot;
</code></pre>
<p>So this compiles using the function:</p>
<div class="comparison">
<div>
<h4 id="prql-64"><a class="header" href="#prql-64">PRQL</a></h4>
<pre><code class="language-prql">from employees
aggregate [average salary]
</code></pre>
</div>
<div>
<h4 id="sql-64"><a class="header" href="#sql-64">SQL</a></h4>
<pre><code class="language-sql">SELECT
  AVG(salary)
FROM
  employees
</code></pre>
</div>
</div>
<p>Here’s an example of a more involved use of an s-string:</p>
<div class="comparison">
<div>
<h4 id="prql-65"><a class="header" href="#prql-65">PRQL</a></h4>
<pre><code class="language-prql">from de=dept_emp
join s=salaries side:left [
  (s.emp_no == de.emp_no),
  s&quot;&quot;&quot;({s.from_date}, {s.to_date})
  OVERLAPS
  ({de.from_date}, {de.to_date})&quot;&quot;&quot;
]
</code></pre>
</div>
<div>
<h4 id="sql-65"><a class="header" href="#sql-65">SQL</a></h4>
<pre><code class="language-sql">SELECT
  de.*,
  s.*
FROM
  dept_emp AS de
  LEFT JOIN salaries AS s ON s.emp_no = de.emp_no
  AND (s.from_date, s.to_date) OVERLAPS (de.from_date, de.to_date)
</code></pre>
</div>
</div>
<p>To use brackets in an s-string, use double brackets:</p>
<div class="comparison">
<div>
<h4 id="prql-66"><a class="header" href="#prql-66">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive [
  has_valid_title = s&quot;regexp_contains(title, '([a-z0-9]*-){{2,}}')&quot;
]
</code></pre>
</div>
<div>
<h4 id="sql-66"><a class="header" href="#sql-66">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  regexp_contains(title, '([a-z0-9]*-){2,}') AS has_valid_title
FROM
  employees
</code></pre>
</div>
</div>
<p>For those who have used python, s-strings are similar to python’s f-strings, but
the result is SQL, rather than a string literal — a python f-string of
<code>f&quot;average{col}&quot;</code> where <code>col=&quot;salary&quot;</code> would produce <code>&quot;average(salary)&quot;</code>, with
the quotes. <code>s&quot;average{col}&quot;</code> produces <code>average(salary)</code>, without quotes.</p>
<p>s-strings in user code are intended as an escape-hatch for an unimplemented
feature. If we often need s-strings to express something, that’s a sign we
should implement it in PRQL or PRQL’s stdlib.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Strings in PRQL can use either single or double quotes:</p>
<div class="comparison">
<div>
<h4 id="prql-67"><a class="header" href="#prql-67">PRQL</a></h4>
<pre><code class="language-prql">derive x = &quot;hello world&quot;
</code></pre>
</div>
<div>
<h4 id="sql-67"><a class="header" href="#sql-67">SQL</a></h4>
<pre><code class="language-sql">SELECT
  'hello world' AS x
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-68"><a class="header" href="#prql-68">PRQL</a></h4>
<pre><code class="language-prql">derive x = 'hello world'
</code></pre>
</div>
<div>
<h4 id="sql-68"><a class="header" href="#sql-68">SQL</a></h4>
<pre><code class="language-sql">SELECT
  'hello world' AS x
</code></pre>
</div>
</div>
<p>To quote a string containing quotes, either use the “other” type of quote, or
use three-or-more quotes, and close with the same number.</p>
<div class="comparison">
<div>
<h4 id="prql-69"><a class="header" href="#prql-69">PRQL</a></h4>
<pre><code class="language-prql">derive x = '&quot;hello world&quot;'
</code></pre>
</div>
<div>
<h4 id="sql-69"><a class="header" href="#sql-69">SQL</a></h4>
<pre><code class="language-sql">SELECT
  '&quot;hello world&quot;' AS x
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-70"><a class="header" href="#prql-70">PRQL</a></h4>
<pre><code class="language-prql">derive x = &quot;&quot;&quot;I said &quot;hello world&quot;!&quot;&quot;&quot;
</code></pre>
</div>
<div>
<h4 id="sql-70"><a class="header" href="#sql-70">SQL</a></h4>
<pre><code class="language-sql">SELECT
  'I said &quot;hello world&quot;!' AS x
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-71"><a class="header" href="#prql-71">PRQL</a></h4>
<pre><code class="language-prql">derive x = &quot;&quot;&quot;&quot;&quot;I said &quot;&quot;&quot;hello world&quot;&quot;&quot;!&quot;&quot;&quot;&quot;&quot;
</code></pre>
</div>
<div>
<h4 id="sql-71"><a class="header" href="#sql-71">SQL</a></h4>
<pre><code class="language-sql">SELECT
  'I said &quot;&quot;&quot;hello world&quot;&quot;&quot;!' AS x
</code></pre>
</div>
</div>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="language-features/strings.html#admonition-note"></a></p>
</div>
<div>
<p>Currently PRQL does not adjust escape characters.</p>
</div>
</div>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="language-features/strings.html#admonition-warning"></a></p>
</div>
<div>
<p>Currently PRQL allows multiline strings with either a single character or
multiple character quotes. This may change for strings using a single character
quote in future versions.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdlib"><a class="header" href="#stdlib">Stdlib</a></h1>
<p>The standard library is currently fairly limited, and we’re very to expanding
it. If we find ourselves using <a href="./language-features/s-strings.html">s-strings</a> for
something frequently, raise an issue and we’ll add it to the stdlib.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="stdlib.html#admonition-note"></a></p>
</div>
<div>
<p>Currently the stdlib implementation doesn’t support different DB implementations itself;
those need to be built deeper into the compiler. We’ll resolve this at some point. Until
then, we’ll only add functions here that are broadly supported by most DBs.</p>
</div>
</div>
<p>Here’s the source of the current <a href="https://github.com/prql/prql/blob/main/prql-compiler/src/semantic/stdlib.prql">PRQL
stdlib</a>:</p>
<pre><code class="language-prql_no_test"># Transform type definitions

# make sure to update cast_transfrom if you change any of the declarations here

func from&lt;table&gt; source -&gt; 0
func select&lt;table&gt; assigns tbl -&gt; 0
func filter&lt;table&gt; condition tbl -&gt; 0
func derive&lt;table&gt; assigns tbl -&gt; 0
func aggregate&lt;table&gt; assigns tbl -&gt; 0
func sort&lt;table&gt; by tbl -&gt; 0
func take&lt;table&gt; expr tbl -&gt; 0
func join&lt;table&gt; with filter side:inner tbl -&gt; 0
func group&lt;table&gt; by pipeline tbl -&gt; 0
func window&lt;table&gt; rows:0..0 range:0..0 expanding:false rolling:0 pipeline tbl -&gt; 0

# Aggregate Functions

func min &lt;scalar|column&gt; column -&gt;  s&quot;MIN({column})&quot;
func max &lt;scalar|column&gt; column -&gt;  s&quot;MAX({column})&quot;
func sum &lt;scalar|column&gt; column -&gt;  s&quot;SUM({column})&quot;
func avg &lt;scalar|column&gt; column -&gt;  s&quot;AVG({column})&quot;
func stddev &lt;scalar|column&gt; column -&gt;  s&quot;STDDEV({column})&quot;
func average &lt;scalar|column&gt; column -&gt;  s&quot;AVG({column})&quot;
func count &lt;scalar|column&gt; non_null:s&quot;*&quot; -&gt;  s&quot;COUNT({non_null})&quot;
func round &lt;scalar|column&gt; column n_digits -&gt;  s&quot;ROUND({column}, {n_digits})&quot;
# TODO: Possibly make this into `count distinct:true` (or like `distinct:` as an
# abbreviation of that?)
func count_distinct &lt;scalar|column&gt; column -&gt;  s&quot;COUNT(DISTINCT `{column}`)&quot;

# TODO: Introduce a notation for getting start and end out of a ranges
# could be range.0? or range.start? But to make this happen, we need to make
# changes to how variables are resolved.
func in&lt;bool&gt; range value -&gt;  s&quot;{value} BETWEEN {range}&quot;

# Casting functions

func as&lt;scalar&gt; column type -&gt;  s&quot;CAST({column} AS {type})&quot;

# Window functions
func lag&lt;column&gt; offset column -&gt;  s&quot;LAG({column}, {offset})&quot;
func lead&lt;column&gt; offset column -&gt;  s&quot;LEAD({column}, {offset})&quot;
func first&lt;column&gt; offset column -&gt;  s&quot;FIRST_VALUE({column}, {offset})&quot;
func last&lt;column&gt; offset column -&gt;  s&quot;LAST_VALUE({column}, {offset})&quot;
func rank&lt;column&gt; -&gt;  s&quot;RANK()&quot;
func rank_dense&lt;column&gt; -&gt;  s&quot;DENSE_RANK()&quot;
func row_number&lt;column&gt; -&gt;  s&quot;ROW_NUMBER()&quot;

# Logical functions
func coalesce value default -&gt; s&quot;COALESCE({value}, {default})&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bindings"><a class="header" href="#bindings">Bindings</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-prql-java"><a class="header" href="#java-prql-java">Java (prql-java)</a></h1>
<p><code>prql-java</code> offers rust bindings to the <code>prql-compiler</code> rust library. It
exposes a java native method <code>public static native String toSql(String query)</code>.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.prqllang&lt;/groupId&gt;
    &lt;artifactId&gt;prql-java&lt;/artifactId&gt;
    &lt;version&gt;${PRQL_VERSION}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-java">import org.prqllang.prql4j.PrqlCompiler;

class Main {
    public static void main(String[] args) {
        String sql = PrqlCompiler.toSql(&quot;from table&quot;);
        System.out.println(sql);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-prql-js"><a class="header" href="#javascript-prql-js">Javascript (prql-js)</a></h1>
<p>JavaScript bindings for <a href="https://github.com/prql/prql/"><code>prql-compiler</code></a>. Check out <a href="https://prql-lang.org">https://prql-lang.org</a> for more
context.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-sh">npm install prql-js
</code></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Currently these functions are exposed</p>
<pre><code class="language-javascript">function compile(prql_string) # returns CompileResult
function to_sql(prql_string) # returns SQL string
function to_json(prql_string) # returns JSON string ( needs JSON.parse() to get the json)
</code></pre>
<h3 id="from-nodejs"><a class="header" href="#from-nodejs">From NodeJS</a></h3>
<pre><code class="language-javascript">const prql = require(&quot;prql-js&quot;);

const { sql, error } = compile(`from employees | select first_name`);
console.log(sql);
// handle error as well...
</code></pre>
<h3 id="from-a-browser"><a class="header" href="#from-a-browser">From a Browser</a></h3>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;./node_modules/prql-js/dist/web/prql_js.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      const { compile } = wasm_bindgen;

      async function run() {
        await wasm_bindgen(&quot;./node_modules/prql-js/dist/web/prql_js_bg.wasm&quot;);
        const { sql, error } = compile(&quot;from employees | select first_name&quot;);

        console.log(sql);
        // handle error as well...
      }

      run();
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="from-a-framework-or-a-bundler"><a class="header" href="#from-a-framework-or-a-bundler">From a Framework or a Bundler</a></h3>
<pre><code class="language-typescript">import compile from &quot;prql-js/dist/bundler&quot;;

const { sql, error } = compile(`from employees | select first_name`);
console.log(sql);
// handle error as well...
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>This uses
<a href="https://rustwasm.github.io/docs/wasm-pack/tutorials/npm-browser-packages/index.html"><code>wasm-pack</code></a>
to generate bindings<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>though we would be very open to other approaches, and used <code>trunk</code>
successfully in a rust-driven approach to this, RIP <code>prql-web</code>.</p>
</div>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<p>Build:</p>
<pre><code class="language-sh">npm run build-all
</code></pre>
<p>This builds Node, bundler and web packages in the <code>dist</code> path.</p>
<p>Test:</p>
<pre><code class="language-sh">wasm-pack test --firefox
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-prql-python"><a class="header" href="#python-prql-python">Python (prql-python)</a></h1>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p><code>pip install prql-python</code></p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-python">import prql_python as prql

prql_query = &quot;&quot;&quot;
    from employees
    join salaries [emp_id]
    group [dept_id, gender] (
      aggregate [
        avg_salary = average salary
      ]
    )
&quot;&quot;&quot;

sql = prql.to_sql(prql_query)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-prql-compiler"><a class="header" href="#rust-prql-compiler">Rust (prql-compiler)</a></h1>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<pre><code>cargo new myproject
cd myproject
cargo add prql-compiler
</code></pre>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<p><code>cargo run</code></p>
<h4 id="srcmainrs"><a class="header" href="#srcmainrs">src/main.rs:</a></h4>
<pre><pre class="playground"><code class="language-rust">use prql_compiler::compile;

fn main() {
    let prql = &quot;from employees | select [name,age]  &quot;;
    let sql = compile(prql).unwrap();
    println!(&quot;{:?}&quot;, sql.replace(&quot;\n&quot;, &quot; &quot;));
}

</code></pre></pre>
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml:</a></h4>
<pre><code>[package]
name = &quot;myproject&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
prql-compiler = &quot;0.2.2&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrations"><a class="header" href="#integrations">Integrations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dbt-prql"><a class="header" href="#dbt-prql">dbt-prql</a></h1>
<blockquote>
<p>Original docs at <a href="https://github.com/prql/dbt-prql">https://github.com/prql/dbt-prql</a></p>
</blockquote>
<p><a href="https://github.com/prql/dbt-prql">dbt-prql</a> allows writing PRQL in dbt models.
This combines the benefits of PRQL’s power &amp; simplicity <em>within</em> queries, with
dbt’s version control, lineage &amp; testing <em>across</em> queries.</p>
<p>Once <code>dbt-prql</code> in installed, dbt commands compile PRQL between <code>{% prql %}</code> &amp;
<code>{% endprql %}</code> jinja tags to SQL as part of dbt’s compilation. No additional
config is required.</p>
<h2 id="examples-10"><a class="header" href="#examples-10">Examples</a></h2>
<h3 id="simple-example"><a class="header" href="#simple-example">Simple example</a></h3>
<pre><code class="language-prql_no_test">{% prql %}
from employees
filter (age | in 20..30)
{% endprql %}
</code></pre>
<p>…would appear to dbt as:</p>
<pre><code class="language-sql">SELECT
  employees.*
FROM
  employees
WHERE
  age BETWEEN 20
  AND 30
</code></pre>
<h3 id="less-simple-example"><a class="header" href="#less-simple-example">Less simple example</a></h3>
<pre><code class="language-prql_no_test">{% prql %}
from {{ source('salesforce', 'in_process') }}
derive expected_sales = probability * value
join {{ ref('team', 'team_sales') }} [name]
group name (
  aggregate (expected_sales)
)
{% endprql %}
</code></pre>
<p>…would appear to dbt as:</p>
<pre><code class="language-sql">SELECT
  name,
  {{ source('salesforce', 'in_process') }}.probability * {{ source('salesforce', 'in_process') }}.value AS expected_sales
FROM
  {{ source('salesforce', 'in_process') }}
  JOIN {{ ref('team', 'team_sales') }} USING(name)
GROUP BY
  name
</code></pre>
<p>…and then dbt will compile the <code>source</code> and <code>ref</code>s to a full SQL query.</p>
<h3 id="replacing-macros"><a class="header" href="#replacing-macros">Replacing macros</a></h3>
<p>dbt’s use of macros has saved many of us many lines of code, and even saved some
people some time. But imperatively programming text generation with code like
<code>if not loop.last</code> is not our highest calling. It’s the “necessary” part rather
than beautiful part of dbt.</p>
<p>Here’s the canonical example of macros in the <a href="https://docs.getdbt.com/tutorial/learning-more/using-jinja">dbt
documentation</a>:</p>
<pre><code class="language-sql">{%- set payment_methods = [&quot;bank_transfer&quot;, &quot;credit_card&quot;, &quot;gift_card&quot;] -%}

select
order_id,
{%- for payment_method in payment_methods %}
sum(case when payment_method = '{{payment_method}}' then amount end) as {{payment_method}}_amount
{%- if not loop.last %},{% endif -%}
{% endfor %}
from {{ ref('raw_payments') }}
group by 1
</code></pre>
<p>Here’s that model using PRQL<sup class="footnote-reference"><a href="#1">1</a></sup>, including the prql jinja tags.</p>
<pre><code class="language-prql_no_test">{% prql %}
func filter_amount method -&gt; s&quot;sum(case when payment_method = '{method}' then amount end) as {method}_amount&quot;

from {{ ref('raw_payments') }}
group order_id (
  aggregate [
    filter_amount bank_transfer,
    filter_amount credit_card,
    filter_amount gift_card,
  ]
)
{% endprql %}
</code></pre>
<p>As well the query being simpler in its final form, writing in PRQL also gives us
live feedback around any errors, on every keystroke. Though there’s much more to
come, check out the current version on <a href="https://prql-lang.org/playground/">PRQL
Playground</a>.</p>
<h2 id="what-it-does"><a class="header" href="#what-it-does">What it does</a></h2>
<p>When dbt compiles models to SQL queries:</p>
<ul>
<li>Any text in a dbt model between <code>{% prql %}</code> and <code>{% endprql %}</code> tags is
compiled from PRQL to SQL before being passed to dbt.</li>
<li>The PRQL complier passes text that’s containing <code>{{</code> &amp; <code>}}</code> through to dbt
without modification, which allows us to embed jinja expressions in PRQL.
(This was added to PRQL specifically for this use-case.)</li>
<li>dbt will then compile the resulting model into its final form of raw SQL, and
dispatch it to the database, as per usual.</li>
</ul>
<p>There’s no config needed in the dbt project; this works automatically on any dbt
command (e.g. <code>dbt run</code>) assuming <code>dbt-prql</code> is installed.</p>
<h2 id="installation-4"><a class="header" href="#installation-4">Installation</a></h2>
<pre><code class="language-sh">pip install dbt-prql
</code></pre>
<h2 id="current-state"><a class="header" href="#current-state">Current state</a></h2>
<p>Currently this is new, but fairly feature-complete. It’s enthusiastically
supported — if there are any problems, please open an issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jupyter"><a class="header" href="#jupyter">Jupyter</a></h1>
<blockquote>
<p>Original docs at <a href="https://pyprql.readthedocs.io/en/latest/magic_readme.html">https://pyprql.readthedocs.io/en/latest/magic_readme.html</a></p>
</blockquote>
<p>Work with pandas and PRQL in an IPython terminal or Jupyter notebook.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>This is a thin wrapper around the fantastic
<a href="https://github.com/catherinedevlin/ipython-sql">IPython-sql</a> magic.
Roughly speaking,
all we do is parse PRQL to SQL and pass that through to <code>ipython-sql</code>.
A full documentation of the supported features is available at their
<a href="https://github.com/catherinedevlin/ipython-sql">repository</a>.
Here, we document those places where we differ from them,
plus those features we think you are mostly likely to find useful.</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<h3 id="installation-5"><a class="header" href="#installation-5">Installation</a></h3>
<p>If you have already installed PyPRQL into your environment,
then you should be could to go!
We bundle in <code>IPython</code> and <code>pandas</code>,
though you’ll need to install <code>Jupyter</code> separately.
If you haven’t installed PyPRQL,
that’s as simple as:</p>
<pre><code class="language-shell">pip install pyprql
</code></pre>
<h3 id="set-up"><a class="header" href="#set-up">Set Up</a></h3>
<p>Open up either an <code>IPython</code> terminal or <code>Jupyter</code> notebook. First, we need to
load the extension and connect to a database.</p>
<pre><code class="language-python">In [1]: %load_ext pyprql.magic

</code></pre>
<h4 id="connecting-a-database"><a class="header" href="#connecting-a-database">Connecting a database</a></h4>
<p>We have two options for connecting a database</p>
<ol>
<li>
<p>Create an in-memory DB. This is the easiest way to get started.</p>
<pre><code class="language-python">In [2]: %prql duckdb:///:memory:
</code></pre>
<p>However, in-memory databases start off empty! So, we need to add some data.
We have a two options:</p>
<ul>
<li>
<p>We can easily add a <a href="https://pandas.pydata.org">pandas</a> dataframe to the <code>DuckDB</code> database
like so:</p>
<pre><code class="language-python">In [3]: %prql --persist df
</code></pre>
<p>where <code>df</code> is a pandas dataframe. This adds a table named <code>df</code> to the
in-memory <code>DuckDB</code> instance.</p>
</li>
<li>
<p>Or download a CSV and query it directly, with DuckDB:</p>
<pre><code class="language-python">!wget https://github.com/graphql-compose/graphql-compose-examples/blob/master/examples/northwind/data/csv/products.csv
</code></pre>
<p>…and then <code>from products.csv</code> will work.</p>
</li>
</ul>
</li>
<li>
<p>Connect to an existing database</p>
<p>When connecting to a database, pass the connection string as an argument to the
line magic <code>%prql</code>. The connection string needs to be in <a href="https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls">SQLAlchemy
format</a>, so any connection supported by <code>SQLAlchemy</code> is supported by
the magic. Additional connection parameters can be passed as a dictionary using
the <code>--connection_arguments</code> flag to the the <code>%prql</code> line magic. We ship with
the necessary extensions to use <a href="https://duckdb.org">DuckDB</a> as the backend, and here
connect to an in-memory database.</p>
</li>
</ol>
<h3 id="querying"><a class="header" href="#querying">Querying</a></h3>
<p>Now, let’s do a query! By default, <code>PRQLMagic</code> always returns the results as
dataframe, and always prints the results. The results of the previous query are
accessible in the <code>_</code> variable.</p>
<p>These examples are based on the <code>products.csv</code> example above.</p>
<pre><code class="language-python">

In [4]: %%prql
   ...: from p = products.csv
   ...: filter supplierID == 1

Done.
Returning data to local variable _
   productID    productName  supplierID  categoryID      quantityPerUnit  unitPrice  unitsInStock  unitsOnOrder  reorderLevel  discontinued
0          1           Chai           1           1   10 boxes x 20 bags       18.0            39             0            10             0
1          2          Chang           1           1   24 - 12 oz bottles       19.0            17            40            25             0
2          3  Aniseed Syrup           1           2  12 - 550 ml bottles       10.0            13            70            25             0
</code></pre>
<pre><code class="language-python">In [5]: %%prql
   ...: from p = products.csv
   ...: group categoryID (
   ...:   aggregate [average unitPrice]
   ...: )

Done.
Returning data to local variable _
   categoryID  avg(&quot;unitPrice&quot;)
0           1         37.979167
1           2         23.062500
2           7         32.370000
3           6         54.006667
4           8         20.682500
5           4         28.730000
6           3         25.160000
7           5         20.250000
</code></pre>
<p>We can capture the results into a different variable like so:</p>
<pre><code class="language-python">In [6]: %%prql results &lt;&lt;
   ...: from p = products.csv
   ...: aggregate [min unitsInStock, max unitsInStock]

Done.
Returning data to local variable results
   min(&quot;unitsInStock&quot;)  max(&quot;unitsInStock&quot;)
0                    0                  125
</code></pre>
<p>Now, the output of the query is saved to <code>results</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefect"><a class="header" href="#prefect">Prefect</a></h1>
<p>Because Prefect is in native python, it’s extremely easy to integrate with PRQL.</p>
<p>With a Postgres Task, replace:</p>
<pre><code class="language-python">PostgresExecute.run(..., query=sql)
</code></pre>
<p>…with…</p>
<pre><code class="language-python">PostgresExecute.run(..., query=pyprql.to_sql(prql))
</code></pre>
<p>We’re big fans of Prefect, and if there is anything that would make the
integration easier, please open an issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-11"><a class="header" href="#examples-11">Examples</a></h1>
<p>These examples are rewritten from other languages such as SQL. They try to express real-world problems in PRQL, covering most of the language features. We are looking for different use-cases of data transformation, be it database queries, semantic business modeling or data cleaning.</p>
<p>If you want to help, translate some of your queries to PRQL and <a href="https://github.com/prql/prql/pulls">open a PR</a> to add them here!</p>
<!-- TODO: toc -->
<div style="break-before: page; page-break-before: always;"></div><div class="comparison">
<div>
<h4 id="prql-72"><a class="header" href="#prql-72">PRQL</a></h4>
<pre><code class="language-prql">from employees
filter country == &quot;USA&quot;                       # Each line transforms the previous result.
derive [                                     # This adds columns / variables.
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost  # Variables can use other variables.
]
filter gross_cost &gt; 0
group [title, country] (                     # For each group use a nested pipeline
  aggregate [                                # Aggregate each group to a single row
    average salary,
    average gross_salary,
    sum salary,
    sum gross_salary,
    average gross_cost,
    sum_gross_cost = sum gross_cost,
    ct = count,
  ]
)
sort sum_gross_cost
filter ct &gt; 200
take 20
</code></pre>
</div>
<div>
<h4 id="sql-72"><a class="header" href="#sql-72">SQL</a></h4>
<pre><code class="language-sql">SELECT
  title,
  country,
  AVG(salary),
  AVG(salary + payroll_tax),
  SUM(salary),
  SUM(salary + payroll_tax),
  AVG(salary + payroll_tax + benefits_cost),
  SUM(salary + payroll_tax + benefits_cost) AS sum_gross_cost,
  COUNT(*) AS ct
FROM
  employees
WHERE
  country = 'USA'
  AND salary + payroll_tax + benefits_cost &gt; 0
GROUP BY
  title,
  country
HAVING
  COUNT(*) &gt; 200
ORDER BY
  sum_gross_cost
LIMIT
  20
</code></pre>
</div>
</div>
<div class="comparison">
<div>
<h4 id="prql-73"><a class="header" href="#prql-73">PRQL</a></h4>
<pre><code class="language-prql">from employees
group [emp_no] (
  aggregate [
    emp_salary = average salary     # average salary resolves to &quot;AVG(salary)&quot; (from stdlib)
  ]
)
join titles [emp_no]
group [title] (
  aggregate [
    avg_salary = average emp_salary
  ]
)
select salary_k = avg_salary / 1000 # avg_salary should resolve to &quot;AVG(emp_salary)&quot;
take 10                             # induces new SELECT
derive salary = salary_k * 1000     # salary_k should not resolve to &quot;avg_salary / 1000&quot;
</code></pre>
</div>
<div>
<h4 id="sql-73"><a class="header" href="#sql-73">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    emp_no,
    AVG(salary) AS emp_salary
  FROM
    employees
  GROUP BY
    emp_no
)
SELECT
  AVG(table_0.emp_salary) / 1000 AS salary_k,
  AVG(table_0.emp_salary) / 1000 * 1000 AS salary
FROM
  table_0
  JOIN titles USING(emp_no)
GROUP BY
  titles.title
LIMIT
  10
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="single-item-is-coerced-into-a-list"><a class="header" href="#single-item-is-coerced-into-a-list">Single item is coerced into a list</a></h2>
<div class="comparison">
<div>
<h4 id="prql-74"><a class="header" href="#prql-74">PRQL</a></h4>
<pre><code class="language-prql">from employees
select salary
</code></pre>
</div>
<div>
<h4 id="sql-74"><a class="header" href="#sql-74">SQL</a></h4>
<pre><code class="language-sql">SELECT
  salary
FROM
  employees
</code></pre>
</div>
</div>
<p>Same as above but with <code>salary</code> in a list:</p>
<div class="comparison">
<div>
<h4 id="prql-75"><a class="header" href="#prql-75">PRQL</a></h4>
<pre><code class="language-prql">from employees
select [salary]
</code></pre>
</div>
<div>
<h4 id="sql-75"><a class="header" href="#sql-75">SQL</a></h4>
<pre><code class="language-sql">SELECT
  salary
FROM
  employees
</code></pre>
</div>
</div>
<h2 id="multiple-items"><a class="header" href="#multiple-items">Multiple items</a></h2>
<div class="comparison">
<div>
<h4 id="prql-76"><a class="header" href="#prql-76">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive [
  gross_salary = salary + payroll_tax,
  gross_cost = gross_salary + benefits_cost
]
</code></pre>
</div>
<div>
<h4 id="sql-76"><a class="header" href="#sql-76">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary,
  salary + payroll_tax + benefits_cost AS gross_cost
FROM
  employees
</code></pre>
</div>
</div>
<p>Same as above but split into two lines:</p>
<div class="comparison">
<div>
<h4 id="prql-77"><a class="header" href="#prql-77">PRQL</a></h4>
<pre><code class="language-prql">from employees
derive gross_salary = salary + payroll_tax
derive gross_cost = gross_salary + benefits_cost
</code></pre>
</div>
<div>
<h4 id="sql-77"><a class="header" href="#sql-77">SQL</a></h4>
<pre><code class="language-sql">SELECT
  employees.*,
  salary + payroll_tax AS gross_salary,
  salary + payroll_tax + benefits_cost AS gross_cost
FROM
  employees
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="comparison">
<div>
<h4 id="prql-78"><a class="header" href="#prql-78">PRQL</a></h4>
<pre><code class="language-prql">table newest_employees = (
  from employees
  sort tenure
  take 50
)

table average_salaries = (
  from salaries
  group country (
    aggregate average_country_salary = (average salary)
  )
)

from newest_employees
join average_salaries [country]
select [name, salary, average_country_salary]
</code></pre>
</div>
<div>
<h4 id="sql-78"><a class="header" href="#sql-78">SQL</a></h4>
<pre><code class="language-sql">WITH newest_employees AS (
  SELECT
    employees.*
  FROM
    employees
  ORDER BY
    tenure
  LIMIT
    50
), average_salaries AS (
  SELECT
    country,
    AVG(salary) AS average_country_salary
  FROM
    salaries
  GROUP BY
    country
)
SELECT
  name,
  average_salaries.salary,
  average_salaries.average_country_salary
FROM
  newest_employees
  JOIN average_salaries USING(country)
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="comparison">
<div>
<h4 id="prql-79"><a class="header" href="#prql-79">PRQL</a></h4>
<pre><code class="language-prql">from mytable
filter id == $1
</code></pre>
</div>
<div>
<h4 id="sql-79"><a class="header" href="#sql-79">SQL</a></h4>
<pre><code class="language-sql">SELECT
  mytable.*
FROM
  mytable
WHERE
  id = $1
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="employees"><a class="header" href="#employees">Employees</a></h1>
<p>These are homework tasks on <a href="https://github.com/vrajmohan/pgsql-sample-data.git">employees database</a>.</p>
<p>Clone and init the database (requires a local PostgreSQL instance):</p>
<pre><code>$ psql -U postgres -c 'CREATE DATABASE employees;'
$ git clone https://github.com/vrajmohan/pgsql-sample-data.git
$ psql -U postgres -d employees -f pgsql-sample-data/employee/employees.dump
</code></pre>
<p>Execute a PRQL query:</p>
<pre><code>$ cd prql-compiler
$ cargo run compile examples/employees/average-title-salary.prql | psql -U postgres -d employees
</code></pre>
<h2 id="task-1"><a class="header" href="#task-1">Task 1</a></h2>
<blockquote>
<p>rank the employee titles according to the average salary for each department.</p>
</blockquote>
<p>My solution:</p>
<ul>
<li>for each employee, find their average salary,</li>
<li>join employees with their departments and titles (duplicating employees for each of their titles and departments)</li>
<li>group by department and title, aggregating average salary</li>
<li>join with department to get department name</li>
</ul>
<div class="comparison">
<div>
<h4 id="prql-80"><a class="header" href="#prql-80">PRQL</a></h4>
<pre><code class="language-prql">from salaries
group [emp_no] (
  aggregate [emp_salary = average salary]
)
join t=titles [emp_no]
join dept_emp side:left [emp_no]
group [dept_emp.dept_no, t.title] (
  aggregate [avg_salary = average emp_salary]
)
join departments [dept_no]
select [dept_name, title, avg_salary]
</code></pre>
</div>
<div>
<h4 id="sql-80"><a class="header" href="#sql-80">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    emp_no,
    AVG(salary) AS emp_salary
  FROM
    salaries
  GROUP BY
    emp_no
),
table_1 AS (
  SELECT
    dept_emp.dept_no,
    t.title,
    AVG(table_0.emp_salary) AS avg_salary
  FROM
    table_0
    JOIN titles AS t USING(emp_no)
    LEFT JOIN dept_emp USING(emp_no)
  GROUP BY
    dept_emp.dept_no,
    t.title
)
SELECT
  departments.dept_name,
  table_1.title,
  table_1.avg_salary
FROM
  table_1
  JOIN departments USING(dept_no)
</code></pre>
</div>
</div>
<h2 id="task-2"><a class="header" href="#task-2">Task 2</a></h2>
<blockquote>
<p>Estimate distribution of salaries and gender for each department departments.</p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-81"><a class="header" href="#prql-81">PRQL</a></h4>
<pre><code class="language-prql">from employees
join salaries [emp_no]
group [emp_no, gender] (
  aggregate [
    emp_salary = average salary
  ]
)
join de=dept_emp [emp_no] side:left
group [de.dept_no, gender] (
  aggregate [
    salary_avg = average emp_salary,
    salary_sd = stddev emp_salary,
  ]
)
join departments [dept_no]
select [dept_name, gender, salary_avg, salary_sd]
</code></pre>
</div>
<div>
<h4 id="sql-81"><a class="header" href="#sql-81">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    emp_no,
    gender,
    AVG(salary) AS emp_salary
  FROM
    employees
    JOIN salaries USING(emp_no)
  GROUP BY
    emp_no,
    gender
),
table_1 AS (
  SELECT
    de.dept_no,
    de.gender,
    AVG(table_0.emp_salary) AS salary_avg,
    STDDEV(table_0.emp_salary) AS salary_sd
  FROM
    table_0
    LEFT JOIN dept_emp AS de USING(emp_no)
  GROUP BY
    de.dept_no,
    de.gender
)
SELECT
  departments.dept_name,
  table_1.gender,
  table_1.salary_avg,
  table_1.salary_sd
FROM
  table_1
  JOIN departments USING(dept_no)
</code></pre>
</div>
</div>
<h2 id="task-3"><a class="header" href="#task-3">Task 3</a></h2>
<blockquote>
<p>Estimate distribution of salaries and gender for each manager.</p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-82"><a class="header" href="#prql-82">PRQL</a></h4>
<pre><code class="language-prql">from employees
join salaries [emp_no]
group [emp_no, gender] (
  aggregate [
    emp_salary = average salary
  ]
)
join de=dept_emp [emp_no]
join dm=dept_manager [
  (dm.dept_no == de.dept_no) and s&quot;(de.from_date, de.to_date) OVERLAPS (dm.from_date, dm.to_date)&quot;
]
group [dm.emp_no, gender] (
  aggregate [
    salary_avg = average emp_salary,
    salary_sd = stddev emp_salary
  ]
)
derive mng_no = dm.emp_no
join managers=employees [emp_no]
derive mng_name = s&quot;managers.first_name || ' ' || managers.last_name&quot;
select [mng_name, managers.gender, salary_avg, salary_sd]
</code></pre>
</div>
<div>
<h4 id="sql-82"><a class="header" href="#sql-82">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    emp_no,
    gender,
    AVG(salary) AS emp_salary
  FROM
    employees
    JOIN salaries USING(emp_no)
  GROUP BY
    emp_no,
    gender
),
table_1 AS (
  SELECT
    dm.emp_no,
    gender,
    AVG(table_0.emp_salary) AS salary_avg,
    STDDEV(table_0.emp_salary) AS salary_sd,
    dm.emp_no AS mng_no
  FROM
    table_0
    JOIN dept_emp AS de USING(emp_no)
    JOIN dept_manager AS dm ON dm.dept_no = de.dept_no
    AND (de.from_date, de.to_date) OVERLAPS (dm.from_date, dm.to_date)
  GROUP BY
    dm.emp_no,
    gender
)
SELECT
  managers.first_name || ' ' || managers.last_name AS mng_name,
  managers.gender,
  table_1.salary_avg,
  table_1.salary_sd
FROM
  table_1
  JOIN employees AS managers USING(emp_no)
</code></pre>
</div>
</div>
<h2 id="task-4"><a class="header" href="#task-4">Task 4</a></h2>
<blockquote>
<p>Find distributions of titles, salaries and genders for each department.</p>
</blockquote>
<div class="comparison">
<div>
<h4 id="prql-83"><a class="header" href="#prql-83">PRQL</a></h4>
<pre><code class="language-prql">from de=dept_emp
join s=salaries side:left [
  (s.emp_no == de.emp_no),
  s&quot;({s.from_date}, {s.to_date}) OVERLAPS ({de.from_date}, {de.to_date})&quot;
]
group [de.emp_no, de.dept_no] (
  aggregate salary = (average s.salary)
)
join employees [emp_no]
join titles [emp_no]
select [dept_no, salary, employees.gender, titles.title]
</code></pre>
</div>
<div>
<h4 id="sql-83"><a class="header" href="#sql-83">SQL</a></h4>
<pre><code class="language-sql">WITH table_0 AS (
  SELECT
    de.emp_no,
    de.dept_no,
    AVG(s.salary) AS salary
  FROM
    dept_emp AS de
    LEFT JOIN salaries AS s ON s.emp_no = de.emp_no
    AND (s.from_date, s.to_date) OVERLAPS (de.from_date, de.to_date)
  GROUP BY
    de.emp_no,
    de.dept_no
)
SELECT
  table_0.dept_no,
  table_0.salary,
  employees.gender,
  titles.title
FROM
  table_0
  JOIN employees USING(emp_no)
  JOIN titles USING(emp_no)
</code></pre>
</div>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="highlight-prql.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
